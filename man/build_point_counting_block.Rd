% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocessing.R
\name{build_point_counting_block}
\alias{build_point_counting_block}
\title{Build Point Counting Block from Discrete Counts}
\usage{
build_point_counting_block(
  counts_df,
  mineral_cols = NULL,
  apply_clr = FALSE,
  impute = 1e-06,
  samples_order = NULL,
  min_count_per_sample = 10
)
}
\arguments{
\item{counts_df}{Data frame with columns: sample (character/factor) and
one or more numeric columns containing mineral counts or categorical
mineral names. If categorical (e.g., "Qtz", "Fsp"), function will count
occurrences per sample.}

\item{mineral_cols}{Character vector of column names to use as minerals.
If NULL, uses all columns except 'sample'.}

\item{apply_clr}{Logical, apply CLR transformation? (default: FALSE).
If FALSE, returns simplex (proportions). If TRUE, returns CLR coordinates.}

\item{impute}{Small value to add before CLR to avoid log(0) (default: 1e-6).
Only used if apply_clr = TRUE.}

\item{samples_order}{Optional character vector specifying sample order.}

\item{min_count_per_sample}{Minimum total count per sample (default: 10).
Samples with fewer counts are removed with a warning.}
}
\value{
A list with components:
  \item{data_mat}{Matrix (N x D) of compositional data (proportions if apply_clr=FALSE,
    CLR coordinates if apply_clr=TRUE)}
  \item{samples}{Character vector of sample names}
  \item{components}{Character vector of component names}
  \item{total_counts}{Integer vector of total counts per sample}
  \item{is_clr}{Logical, was CLR applied?}
  \item{data_type}{Character, type for use in unmix}
}
\description{
Converts raw point counting data (discrete mineral/component counts) into
compositional data ready for unmixing. This function is specifically for
COUNTING data (integers representing number of grains counted), not
data that are already in proportion/composition form.
}
\details{
**Input Format:**

Point counting data are DISCRETE COUNTS (integers) from counting exercises.
Examples: counted 100 grains, 40 were Quartz, 30 Feldspar, 30 Lithics.

If counts_df has one row per grain (long format), function will aggregate by sample.
If counts_df has one row per sample with counts in columns (wide format), uses directly.

This function will:
1. Aggregate counts if needed
2. Filter samples with low counts
3. Convert to proportions (closure to simplex: divide by row sum)
4. Optionally apply CLR transformation

CLR transformation: clr(x) = log(x) - mean(log(x))
Converts from D-1 dimensional simplex to D-dimensional Euclidean space.
}
\examples{
\dontrun{
# Example 1: Long format (one row per grain counted)
bp_raw <- data.frame(
  sample = rep(c("S1", "S2", "S3"), c(200, 180, 220)),
  mineral = sample(c("Qtz", "Fsp", "Lith", "Musc"), 600, replace = TRUE,
                  prob = c(0.4, 0.3, 0.2, 0.1))
)

bp_block <- build_point_counting_block(
  counts_df = bp_raw,
  mineral_cols = "mineral",  # column with mineral names
  apply_clr = FALSE  # keep as proportions
)

# Example 2: Wide format (one row per sample, counts in columns)
bp_wide <- data.frame(
  sample = c("S1", "S2", "S3"),
  Qtz = c(80, 70, 90),      # these are COUNTS (integers)
  Fsp = c(60, 55, 65),
  Lith = c(40, 35, 45),
  Musc = c(20, 20, 20)
)

bp_block <- build_point_counting_block(
  counts_df = bp_wide,
  mineral_cols = c("Qtz", "Fsp", "Lith", "Musc"),
  apply_clr = TRUE  # transform to CLR
)

# Use in unmix
result <- unmix(
  data_list = list(DZ = dz_mat, BP = bp_block$data_mat),
  data_types = c(DZ = "continuous", BP = bp_block$data_type),
  K = 3
)
}

}
