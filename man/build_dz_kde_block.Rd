% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocessing.R
\name{build_dz_kde_block}
\alias{build_dz_kde_block}
\title{Build KDE-Discretized Block from Detrital Zircon Ages}
\usage{
build_dz_kde_block(
  ages_df,
  age_vars = NULL,
  n_points = 129,
  probs = c(0.03, 0.97),
  bw_method = c("SJ", "nrd0"),
  bw_multiplier = 1,
  samples_order = NULL
)
}
\arguments{
\item{ages_df}{Data frame with columns: sample (character/factor) and 
one or more numeric columns containing age measurements (e.g., age_concordia,
ti_temp, eu_eu, etc.). Each row is one grain measurement.}

\item{age_vars}{Character vector of column names to discretize. If NULL,
uses all numeric columns except 'sample'.}

\item{n_points}{Integer, number of bins for discretization (default: 129).
Higher = more resolution, but more memory.}

\item{probs}{Numeric vector of length 2, quantiles to use for grid bounds
(default: c(0.03, 0.97)). This removes extreme outliers.}

\item{bw_method}{Bandwidth selection method: "SJ" (Sheather-Jones, default)
or "nrd0" (Scott's rule). SJ is generally better but slower.}

\item{bw_multiplier}{Bandwidth multiplier (default: 1.0). Values > 1 smooth
more, < 1 smooth less.}

\item{samples_order}{Optional character vector specifying sample order in
output matrix. If NULL, uses alphabetical order.}
}
\value{
A list with components:
  \item{DZ_mat}{Matrix (N x F*n_points) of discretized PDFs, where N is
    number of samples and F is number of features (age_vars)}
  \item{samples}{Character vector of sample names (row names of DZ_mat)}
  \item{age_vars}{Character vector of feature names}
  \item{grids}{Named list of evaluation grids (one per feature)}
  \item{n_points}{Number of bins per feature}
}
\description{
Converts raw detrital zircon age measurements into discretized probability
density functions (PDFs) via kernel density estimation (KDE). This is the
recommended format for the "continuous" data type in provenance_unmix().
}
\details{
For each sample and each age variable:
1. Compute bandwidth using specified method (SJ or nrd0)
2. Create evaluation grid from quantiles (probs) of all data
3. Evaluate KDE at grid points
4. Normalize to unit area (trapezoidal rule)

The resulting matrix has F*n_points columns, with columns ordered as:
[var1_bin1, var1_bin2, ..., var1_binN, var2_bin1, ..., varF_binN]
}
\examples{
\dontrun{
# Example data
dz_raw <- data.frame(
  sample = rep(c("S1", "S2", "S3"), each = 100),
  age_concordia = c(rnorm(100, 500, 50), rnorm(100, 1000, 100), rnorm(100, 1500, 150)),
  ti_temp = rnorm(300, 750, 50),
  th_u = rlnorm(300, 0, 0.5)
)

# Build KDE block
dz_block <- build_dz_kde_block(
  ages_df = dz_raw,
  age_vars = c("age_concordia", "ti_temp", "th_u"),
  n_points = 129
)

# Use in provenance_unmix
result <- provenance_unmix(
  data_list = list(DZ = dz_block$DZ_mat, BP = bp_counts),
  data_types = c(DZ = "continuous", BP = "compositional"),
  K = 3
)
}

}
