% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocessing.R
\name{build_compositional_block}
\alias{build_compositional_block}
\title{Build Compositional Block from Data Already in Compositional Form}
\usage{
build_compositional_block(
  comp_df,
  comp_cols = NULL,
  apply_clr = FALSE,
  impute = 1e-06,
  samples_order = NULL,
  check_closure = TRUE,
  closure_tolerance = 0.01
)
}
\arguments{
\item{comp_df}{Data frame with columns: sample (character/factor) and
one or more numeric columns containing compositional data (proportions).
Values should sum to ~1.0 for each sample (small deviations are normalized).}

\item{comp_cols}{Character vector of column names to use as components.
If NULL, uses all numeric columns except 'sample'.}

\item{apply_clr}{Logical, apply CLR transformation? (default: FALSE).
If FALSE, returns simplex (proportions). If TRUE, returns CLR coordinates.}

\item{impute}{Small value to add before CLR to avoid log(0) (default: 1e-6).
Only used if apply_clr = TRUE.}

\item{samples_order}{Optional character vector specifying sample order.}

\item{check_closure}{Logical, check if rows sum to ~1? (default: TRUE).
If TRUE and row sums deviate significantly from 1, issues a warning.}

\item{closure_tolerance}{Tolerance for closure check (default: 0.01).
Rows must sum to 1 Â± tolerance.}
}
\value{
A list with components:
  \item{data_mat}{Matrix (N x D) of compositional data (proportions if apply_clr=FALSE,
    CLR coordinates if apply_clr=TRUE)}
  \item{samples}{Character vector of sample names}
  \item{components}{Character vector of component names}
  \item{row_sums}{Numeric vector of row sums (should be ~1.0)}
  \item{is_clr}{Logical, was CLR applied?}
  \item{data_type}{Character, type for use in unmix}
}
\description{
Processes data that are ALREADY compositional (i.e., proportions/compositions
that sum to 1) for use in source unmixing. This is for data that are
already closed to the simplex, NOT for raw counts.
}
\details{
**Input Format:**

Compositional data are already in PROPORTION form (values between 0 and 1, sum to 1).
Examples:
- Modal mineralogy from XRD (already normalized to 100%)
- Geochemical oxides (e.g., SiO2=0.65, Al2O3=0.15, ..., sum=1.00)
- Any data already closed to the simplex

This function will:
1. Validate that data are in [0, 1] range
2. Optionally check that rows sum to ~1.0
3. Re-normalize to simplex (closure) to ensure exact sum=1
4. Optionally apply CLR transformation

**Difference from build_point_counting_block():**

- `build_point_counting_block()`: Input = COUNTS (integers: 40, 30, 30, ...)
- `build_compositional_block()`: Input = PROPORTIONS (decimals: 0.40, 0.30, 0.30, ...)
}
\examples{
\dontrun{
# Example: Modal mineralogy data (already proportions)
modal_data <- data.frame(
  sample = c("S1", "S2", "S3"),
  Qtz = c(0.40, 0.35, 0.45),     # these are PROPORTIONS (sum to 1)
  Fsp = c(0.30, 0.35, 0.30),
  Lith = c(0.20, 0.20, 0.15),
  Musc = c(0.10, 0.10, 0.10)
)

comp_block <- build_compositional_block(
  comp_df = modal_data,
  comp_cols = c("Qtz", "Fsp", "Lith", "Musc"),
  apply_clr = TRUE,
  check_closure = TRUE
)

# Use in unmix
result <- unmix(
  data_list = list(DZ = dz_mat, Modal = comp_block$data_mat),
  data_types = c(DZ = "continuous", Modal = comp_block$data_type),
  K = 3
)
}

}
