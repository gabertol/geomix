% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocessing.R
\name{build_kde_block}
\alias{build_kde_block}
\title{Build KDE-Discretized Block from Continuous Distributional Data}
\usage{
build_kde_block(
  data_df,
  vars = NULL,
  n_points = 129,
  probs = c(0.03, 0.97),
  bw_method = c("SJ", "nrd0"),
  bw_multiplier = 1,
  samples_order = NULL
)
}
\arguments{
\item{data_df}{Data frame with columns: sample (character/factor) and
one or more numeric columns containing continuous measurements (e.g.,
detrital zircon ages, apatite fission track ages, trace element ratios, etc.).
Each row is one grain/measurement.}

\item{vars}{Character vector of column names to discretize. If NULL,
uses all numeric columns except 'sample'.}

\item{n_points}{Integer, number of bins for discretization (default: 129).
Higher = more resolution, but more memory.}

\item{probs}{Numeric vector of length 2, quantiles to use for grid bounds
(default: c(0.03, 0.97)). This removes extreme outliers.}

\item{bw_method}{Bandwidth selection method: "SJ" (Sheather-Jones, default)
or "nrd0" (Scott's rule). SJ is generally better but slower.}

\item{bw_multiplier}{Bandwidth multiplier (default: 1.0). Values > 1 smooth
more, < 1 smooth less.}

\item{samples_order}{Optional character vector specifying sample order in
output matrix. If NULL, uses alphabetical order.}
}
\value{
A list with components:
  \item{data_mat}{Matrix (N x F*n_points) of discretized PDFs, where N is
    number of samples and F is number of features (vars)}
  \item{samples}{Character vector of sample names (row names of data_mat)}
  \item{vars}{Character vector of feature names}
  \item{grids}{Named list of evaluation grids (one per feature)}
  \item{n_points}{Number of bins per feature}
  \item{data_type}{Character, type for use in unmix ("continuous")}
}
\description{
Converts continuous distributional measurements into discretized probability
density functions (PDFs) via kernel density estimation (KDE). This is the
recommended format for the "continuous" data type in unmix().
}
\details{
For each sample and each variable:
1. Compute bandwidth using specified method (SJ or nrd0)
2. Create evaluation grid from quantiles (probs) of all data
3. Evaluate KDE at grid points
4. Normalize to unit area (trapezoidal rule)

The resulting matrix has F*n_points columns, with columns ordered as:
[var1_bin1, var1_bin2, ..., var1_binN, var2_bin1, ..., varF_binN]
}
\examples{
\dontrun{
# Example 1: Detrital zircon ages
dz_raw <- data.frame(
  sample = rep(c("S1", "S2", "S3"), each = 100),
  age_concordia = c(rnorm(100, 500, 50), rnorm(100, 1000, 100), rnorm(100, 1500, 150)),
  ti_temp = rnorm(300, 750, 50),
  th_u = rlnorm(300, 0, 0.5)
)

kde_block <- build_kde_block(
  data_df = dz_raw,
  vars = c("age_concordia", "ti_temp", "th_u"),
  n_points = 129
)

# Example 2: Apatite fission track ages
apt_raw <- data.frame(
  sample = rep(c("S1", "S2", "S3"), each = 80),
  age_ft = rnorm(240, 100, 20),
  age_u_pb = rnorm(240, 500, 50)
)

apt_block <- build_kde_block(
  data_df = apt_raw,
  vars = c("age_ft", "age_u_pb")
)

# Use in unmix
result <- unmix(
  data_list = list(DZ = kde_block$data_mat, APT = apt_block$data_mat),
  data_types = c(DZ = "continuous", APT = "continuous"),
  K = 3
)
}

}
